\section{Related Work}
\label{sec:related-work}

% Many resourcess have been useful in developing the \speculake exploit 
% model.  

\subsection{Weird Machines}

\speculake shares many properties with \textit{weird machines}---a machine which
takes advantage of bugs or unexpected idiosyncracies in existing systems to
perform arbitrary
computation~\cite{weird_machines,bratus2011exploit}. In
particular \speculake showcases the ability to execute dead code.

Recently there has been a trend of features in modern processors such as
multiple threads sharing system resources and optimizations done across the
process isolation boundary which lead to opportunities for ``weird
machines''~\cite{d2015exploiting}. In particular, previous examples of ``weird
machines'' include traditional vulnerabilities such as buffer overflows, format
string exploits and return-to-libc attacks without function
calls~\cite{buffer_overflow, format_string_exploit, shacham2007geometry}.
Additionally, unexpected functionality such as instruction-less computing
enables the demonstration of a Turing complete ``weird machine'' by taking
advantage of memory translation tables, page-faults, and hardware exception
handling to effectively compute arithmetic and logical operations without the
processor executing any instructions~\cite{bangert2013page}.

\speculake is a new type of ``weird machine'' that takes advantage of
speculative execution and uses a non-complicit trigger program to execute
otherwise dead code. While previous ``weird machines'' have demonstrated the
capability to execute potentially malicious code in an unexpected manner, we are
the first to exploit speculative execution in order to execute arbitrary
instructions.

\subsection{Red-Pills}
Hardware minutia have also been used to identify and fingerprint execution
environments---in malware this is known as a red-pill~\cite{red-pill} and is
typically used by malware to detect when it is under emulation or a debugging
environment~\cite{lindorfer2011detecting, balzarotti2010efficient,
paleari2009fistful} attempting to circumvent malware detectors. To address
red-pills, systems often employ measures to detect them. ``Bare-metal''
emulation of malware~\cite{kirat2011barebox}, methods to determine if malware is
performing red-pill checks to avoid emulation
environments~\cite{kirat2014barecloud}, and symbolic execution can be used to
combat red-pills by finding environmental triggers in malicious
binaries~\cite{schwartz2010all}. 

Analogously, \speculake undertakes to avoid detection. Unlike previous
red-pills, \speculake complicates analysis and impedes malware detectors with
the use a trigger program and speculative execution. The use of a separate and
seemingly benign trigger program influenced by the adversary enables the
\speculake malware to limit detection by acting benign until triggered to
influence the branch predictor (while still appearing innocuous). 

Additionally, as an \speculake attack is carried out via speculative execution,
the instructions executed and speculative state are not committed to by the
processor and are thus obscured from analysts. Similarly, symbolic execution
will fail to find the speculative gadgets as they are never on the (committed)
execution pathway. More direct analysis such as with break-points (and other
debugging techniques) will not aid in unravelling \speculake malware as
break-points interrupt the control flow of a program and prevent speculative
execution. This allows \speculake to effectively act as a red-pill while
avoiding detection as such.


\subsection{Covert Channels}

There is a plethora of previous research into cache side-channels, examining how
information is leaked between
processes~\cite{percival2005cache,zhang2012cross,osvik2006cache}. This is a key
feature of Spectre~\cite{spectre} and Meltdown~\cite{meltdown}. In \speculake we
use the branch predictor side-channel as a \emph{covert
channel}~\cite{lampson1973note} between an innocent trigger program and malware.
This allows \speculake to use the leaked information from cache as a message to
the malware in order to influence speculative execution pathways.

Previous work has examined various ways of sharing information over covert
channels, such as across virtualized environments on cloud
systems~\cite{wu2012whispers}, using L1 and L2 cache to share
information~\cite{percival2005cache}, measuring temperature to create a thermal
covert channel~\cite{masti2015thermal, bartolini2016capacity} and taking
advantage of processor architecture to leak information~\cite{wang2006covert}.

\speculake uses the branch predictor as a covert channel. The branch predictor
has been considered as a covert channel
before~\cite{evtyushkin2016understanding}. For example, the branch predictor can
be used by two colluding programs to share sensitive information between each
other by timing how long a spy process executes taken (not-taken)
branches~\cite{evtyushkin2015covert}.

While the branch predictor has been used as a covert channel between two
colluding malicious programs, \speculake exemplifies a new covert channel using
the branch predictor in which only one side of the channel is nefarious and the
other is innocent. \speculake takes advantage of a branch predictor side-channel
in \texttt{OpenSSL} and uses it as a covert channel. \texttt{OpenSSL} is not a
malicious colluding program in this case but rather a program whose execution
pathway can be influenced by attackers based on selected cipher suites. This
allows malware to use the branch predictor as an attacker controlled covert
channel between an unsuspecting trigger program and \speculake malware.

% cache~\cite{aciiccmez2010new}, L2
% cache~\cite{ristenpart2009hey,percival2005cache},
% LLC~\cite{ristenpart2009hey,liu2015last}, and branch prediction
% cache~\cite{aciiccmez2007power}. These attacks have also been performed in the
% cloud~\cite{ristenpart2009hey,zhang2012cross},
% browser~\cite{oren2015spy,google_cache_browser}, and security critical
% encryption~\cite{yarom2014recovering,tromer2010efficient} environments,
% demonstrating how ubiquitous hardware side-channel exploits can be. 

% Cache side channels come in many
% variants~\cite{neve2006refined,tromer2010efficient,yarom2014flush+,gruss2016flush+flush}.
% In \speculake, we utilize the \texttt{Flush+Reload} method, where we first flush
% all items from cache, wait for the speculative world to reload a value, and then
% time accesses to reloading each potential value. However, we acknowledge that
% the recent \texttt{Flush+Flush} variant may offer a faster
% alternative~\cite{gruss2016flush+flush}.


\subsection{Speculative Execution}

\speculake builds on Spectre~\cite{spectre} and Meltdown~\cite{meltdown} which
leverage speculative execution to leak sensitive information to unprivileged
processes.  Others have built on Spectre and Meltdown to demonstrate web-based
vulnerabilities~\cite{genkin2018drive, schwarz2018netspectre} as well as
hardware isolation leaks in Intel's SGX~\cite{spectre_sgx,chen2018sgxpectre}.
The branch predictor has also been examined~\cite{evtyushkin2018branchscope} in
the light of Spectre but only as side-channel which is leaking information.
\speculake likewise takes advantage of speculative execution however it does so
to attain hidden arbitrary computation. We believe that \speculake can leverage
these advances in speculative execution malware as well.
