\section{Related Work}
\label{sec:related-work}

% Many resourcess have been useful in developing the \speculake exploit 
% model.  

\subsection{Weird Machines}

\speculake shares many properties with \textit{weird machines}---a machine which
takes advantage of bugs or unexpected idiosyncracies in existing systems to
perform arbitrary
computation~\cite{weird_machines,bratus2011exploit}. In
particular \speculake showcases the ability to execute dead code.

Recently there has been a trend of features in modern processors such as
multiple threads sharing system resources and optimizations done across the
process isolation boundary which lead to opportunities for ``weird
machines''~\cite{d2015exploiting}. In particular, previous examples of ``weird
machines'' include traditional vulnerabilities such as buffer overflows, format
string exploits and return-to-libc attacks without function
calls~\cite{buffer_overflow, format_string_exploit, shacham2007geometry}.
Additionally, unexpected functionality such as instruction-less computing
enables the demonstration of a Turing complete ``weird machine'' by taking
advantage of memory translation tables, page-faults, and hardware exception
handling to effectively compute arithmetic and logical operations without the
processor executing any instructions~\cite{bangert2013page}.

\speculake is a new type of ``weird machine'' that takes advantage of
speculative execution and uses a non-complicit trigger program to execute
otherwise dead code. While previous ``weird machines'' have demonstrated the
capability to execute potentially malicious code in an unexpected manner, we are
the first to exploit speculative execution in order to execute arbitrary
instructions.

\subsection{Red-Pills}
Hardware minutia have also been used to identify and fingerprint execution
environments---in malware this is known as a red-pill~\cite{red-pill} and is
typically used by malware to detect when it is under emulation or a debugging
environment~\cite{lindorfer2011detecting, balzarotti2010efficient,
paleari2009fistful} attempting to circumvent malware detectors. To address
red-pills, systems often employ measures to detect them. ``Bare-metal''
emulation of malware~\cite{kirat2011barebox}, methods to determine if malware is
performing red-pill checks to avoid emulation
environments~\cite{kirat2014barecloud}, and symbolic execution can be used to
combat red-pills by finding environmental triggers in malicious
binaries~\cite{schwartz2010all}. 

Analogously, \speculake undertakes to avoid detection. Unlike previous
red-pills, \speculake complicates analysis and impedes malware detectors with
the use a trigger program and speculative execution. The use of a separate and
seemingly benign trigger program influenced by the adversary enables the
\speculake malware to limit detection by acting benign until triggered to
influence the branch predictor (while still appearing innocuous). 

Additionally, as an \speculake attack is carried out via speculative execution,
the instructions executed and speculative state are not committed to by the
processor and are thus obscured from analysts. Similarly, symbolic execution
will fail to find the speculative gadgets as they are never on the (committed)
execution pathway. More direct analysis such as with break-points (and other
debugging techniques) will not aid in unravelling \speculake malware as
break-points interrupt the control flow of a program and prevent speculative
execution. This allows \speculake to effectively act as a red-pill while
avoiding detection as such.


\subsection{Covert Channels}

There is a plethora of previous research into cache side-channels, examining how
information is leaked between
processes~\cite{percival2005cache,zhang2012cross,osvik2006cache}. This is a key
feature of Spectre~\cite{spectre} and Meltdown~\cite{meltdown}. In \speculake we
use the branch predictor side-channel as a \emph{covert
channel}~\cite{lampson1973note} between an innocent trigger program and malware.
This allows \speculake to use the leaked information from cache as a message to
the malware in order to influence speculative execution pathways.

Previous work has examined various ways of sharing information over covert
channels, such as across virtualized environments on cloud
systems~\cite{wu2012whispers}, using L1 and L2 cache to share
information~\cite{percival2005cache}, measuring temperature to create a thermal
covert channel~\cite{masti2015thermal, bartolini2016capacity} and taking
advantage of processor architecture to leak information~\cite{wang2006covert}.

\speculake uses the branch predictor as a covert channel. The branch predictor
has been considered as a covert channel
before~\cite{evtyushkin2016understanding}. For example, the branch predictor can
be used by two colluding programs to share sensitive information between each
other by timing how long a spy process executes taken (not-taken)
branches~\cite{evtyushkin2015covert}.

While the branch predictor has been used as a covert channel between two
colluding malicious programs, \speculake exemplifies a new covert channel using
the branch predictor in which only one side of the channel is nefarious and the
other is innocent. \speculake takes advantage of a branch predictor side-channel
in \texttt{OpenSSL} and uses it as a covert channel. \texttt{OpenSSL} is not a
malicious colluding program in this case but rather a program whose execution
pathway can be influenced by attackers based on selected cipher suites. This
allows malware to use the branch predictor as an attacker controlled covert
channel between an unsuspecting trigger program and \speculake malware.

% cache~\cite{aciiccmez2010new}, L2
% cache~\cite{ristenpart2009hey,percival2005cache},
% LLC~\cite{ristenpart2009hey,liu2015last}, and branch prediction
% cache~\cite{aciiccmez2007power}. These attacks have also been performed in the
% cloud~\cite{ristenpart2009hey,zhang2012cross},
% browser~\cite{oren2015spy,google_cache_browser}, and security critical
% encryption~\cite{yarom2014recovering,tromer2010efficient} environments,
% demonstrating how ubiquitous hardware side-channel exploits can be. 

% Cache side channels come in many
% variants~\cite{neve2006refined,tromer2010efficient,yarom2014flush+,gruss2016flush+flush}.
% In \speculake, we utilize the \texttt{Flush+Reload} method, where we first flush
% all items from cache, wait for the speculative world to reload a value, and then
% time accesses to reloading each potential value. However, we acknowledge that
% the recent \texttt{Flush+Flush} variant may offer a faster
% alternative~\cite{gruss2016flush+flush}.


\subsection{Speculative Execution}

% Lead in 
Leading up to the discovery and release of the Spectre and Meltdown
vulnerabilities multiple teams were working to reverse engineer the mechanisms
that implemented in the microcode of various processors and document their
behavior~\cite{intel-instruction-tables,project_zero,measuring-cache,measuring-rob}.
Research into branch predictors~\cite{godbolt2016branch}, cache replacement
policies, and reorder buffer construction~\cite{measuring-rob} paved the way for
the branch prediction side-channels employed by Spectre (and subsequently
\speculake).
%Efforts to examine cache and memory security also preempted the Spectre work, 
%including Sophia D'Antoine's thesis work developing a side channel based on 
%instruction interleaving in the CPU~\cite{d2015exploiting}. Similar research into branch 
%predictors, cache replacement policies, and reorder buffer construction including work by Matt 
%Godbolt~\cite{godbolt2016branch}, and Henry Wong~\cite{measuring-rob} paved the runway for 
%dedicated branch prodiction side-channels.

% Discovery & Followup
Given the numerous directions that were being investigated in reverse
engineering Intel processors, multiple teams discovered the Spectre
vulnerabilities concurrently~\cite{spectre, project_zero, evtyushkin2018branchscope, maisuradze2018speculose}.
%These works propose multiple variants making use of branch prediction.
Follow 
up work on speculative execution side channels has also demonstrated
web-based vulnerabilites~\cite{genkin2018drive} as well as hardware isolation  
leaks in Intel's SGX~\cite{spectre_sgx}. At the time of writing multiple sources
have claimed new speculative execution related exploits termed \textit{Spectre-NG}
have been reported to Intel and assigned CVE numbers, though details are
not yet available~\cite{spectre_ng_gossip}.
%We have no details
%on content, though Intel has labeled four as critical and another four 
%as intermediate security flaws~\cite{spectre_ng_gossip}.  


% defenses

%Much like cache side channel vulnerabilities speculative execution is relatively
%critical to processor performance and requires significant software and hardware 
%updates to fully address. 
% Multiple measures have been proposed to combat the 
% individual variants of Spectre.

% One popular approach uses compiler level software patches to wrap sensitive 
% function calls. Retpoline replaces indirect jumps with \texttt{retq}
% instructions that read from the cached stack (and are thus less likely to be
% mis-speculated)~\cite{retpoline}.
% Gruss~\textit{et al.} propose the KAISER software patch to enforce address space
% isolation for kernel and user space proceses~\cite{gruss2017kaslr}. 
% Other proposals have considered hypervisor enforced time domain separation at varying 
% granularity~\cite{renau2018securing}, and fuzzy clocks that would reduce the accuracy 
% of any time based exfiltration pathway~\cite{hu1992reducing}. However, none of these defenses
% fundamentally defeat the use of a branch predictor as a cooperative mechanism
% spanning multiple processes. Intel has released microarchitecture updates for
% its most recent CPUs, but older architectures do not support these updates and
% will remain vulnerable~\cite{intel-micro-patch}.


% Trippel~\textit{et al.} proposes a method of faithfully simulating hardware
% bugs, given a formal model specifying the
% microarchitecture~\cite{trippel2018meltdownprime}. However, such models are
% unlikely to be released by CPU manufacturers, as they generally involve
% closely-guarded trade secrets, making this a less accessible solution for the
% research community.

%\smallskip
%
%We can certainly look forward to more vulnerabilities relating to speculative 
%branching and related hardware side channels. Our work represents an exploit 
%model for these vulnerabilities reliant upon shared hardware resources. 



%%%%%%%%%%%%%%
