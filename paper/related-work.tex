\section{Related Work}
\label{sec:related-work}

% Many resourcess have been useful in developing the \speculake exploit 
% model.  

\subsection{Weird Machines}

\speculake is a \textit{weird machine}---a machine which executes arbitrary
computation using unintended executions paths, often the result of bugs or
attacker exploits~\cite{weird_machines,bratus2011exploit,weird_exploits}. In
particular \speculake takes advantage of speculative execution and a separate
trigger program to execute otherwise dead code.

Previous weird machines have demonstrated many traditional computer
vulnerabilities such as buffer overflows, format string exploits and
return-to-libc attacks without function calls~\cite{buffer_overflow,
format_string_exploit, shacham2007geometry}. 

Additionally, unexpected functionality such as instruction-less
computing~\cite{bangert2013page} enables the demonstration of a Turing complete
weird machine by taking advantage of memory translation tables, page-faults, and
hardware exception handling to effectively compute arithmetic and logical
operations without the processor executing any instructions.

These types of machines are abundant in modern processors~\cite{d2015exploiting}
as multiple threads share system resources cooperatively and optimizations are
often done across the process isolation boundary. 

Whereas previous weird machines have demonstrated the capability to execute
potentially malicious code in an unexpected manner, \speculake showcases the
ability to execute dead code within the speculative world.

\subsection{Red-Pills}
Hardware minutia have also been used to identify and fingerprint execution
environments---in malware this is know as a red-pill~\cite{red-pill} and is
typically used by malware to detect when it is under emulation or a debugging
environment~\cite{lindorfer2011detecting, balzarotti2010efficient,
paleari2009fistful}

% Hardware bare-metal analysis

``Bare-metal'' emulation of malware~\cite{kirat2011barebox}, methods to
determine if malware is performing red-pill checks to avoid emulation
environments~\cite{kirat2014barecloud}, and symbolic execution can also be used
to combat red-pills by finding environmental triggers in malicious
binaries~\cite{schwartz2010all}. 

Unlike other red-pills, \speculake confounds analysts and red-pill detectors
with the use a trigger program and speculative execution. The use of a separate
and benign trigger program controlled by the adversary enables the \speculake
malware to limit detection capabilities. Additionally, as \speculake is executed
via speculative execution, the instructions executed and speculative state are 
also obscured from analysts. 

Similarly, debugging break-points will not enable analysts to debug \speculake
malware as break-points interrupt the control flow of a program and prevent
speculative execution. Symbolic execution will also fail to find the speculative
gadgets as it is never on the execution pathway. This allows \speculake to
effectively act as a red-pill while avoiding detection as such.

\subsection{Covert Channels}

There is a plethora of previous research into cache side-channels, examining how
information is leaked between
processes~\cite{percival2005cache,zhang2012cross,osvik2006cache}. This is a key
feature of Spectre~\cite{spectre} and Meltdown~\cite{meltdown}. In \speculake we
use the branch predictor side-channel as a \emph{covert
channel}~\cite{lampson1973note} between an innocent victim program and malware.
This allows \speculake to use the leaked information from cache as a message to
a colluding malware to make decisions. 

Previous work has examined various ways of sharing information over covert
channels, such as across virtualized environments on cloud
systems~\cite{wu2012whispers}, using L1 and L2 cache to share
information~\cite{percival2005cache}, measuring temperature to create a thermal
covert channel~\cite{masti2015thermal, bartolini2016capacity} and taking
advantage of processor architecture to leak information~\cite{wang2006covert}.

The branch predictor has been used as a covert
channel~\cite{evtyushkin2016understanding}. Previous work has examined the
capability of two colluding programs to share sensitive information between each
other using the branch predictor by timing how long a spy process executes taken
(not-taken) branches~\cite{evtyushkin2015covert}.

\speculake takes advantage of a cache side-channel in \texttt{OpenSSL} and uses
it as a covert channel. \texttt{OpenSSL} is not a malicious colluding program in
this case but rather a program leaking information on which cipher suite has
been selected by attackers, allowing us to use the branch predictor as an
attacker controlled covert channel of an innocent victim program.

% cache~\cite{aciiccmez2010new}, L2
% cache~\cite{ristenpart2009hey,percival2005cache},
% LLC~\cite{ristenpart2009hey,liu2015last}, and branch prediction
% cache~\cite{aciiccmez2007power}. These attacks have also been performed in the
% cloud~\cite{ristenpart2009hey,zhang2012cross},
% browser~\cite{oren2015spy,google_cache_browser}, and security critical
% encryption~\cite{yarom2014recovering,tromer2010efficient} environments,
% demonstrating how ubiquitous hardware side-channel exploits can be. 

% Cache side channels come in many
% variants~\cite{neve2006refined,tromer2010efficient,yarom2014flush+,gruss2016flush+flush}.
% In \speculake, we utilize the \texttt{Flush+Reload} method, where we first flush
% all items from cache, wait for the speculative world to reload a value, and then
% time accesses to reloading each potential value. However, we acknowledge that
% the recent \texttt{Flush+Flush} variant may offer a faster
% alternative~\cite{gruss2016flush+flush}.


\subsection{Speculative Execution}

% Lead in 
Leading up to the discovery and release of the Spectre and Meltdown
vulnerabilities multiple teams were working to reverse engineer the mechanisms
that implemented in the microcode of various processors and document their
behavior~\cite{intel-instruction-tables,project_zero,measuring-cache,measuring-rob}.
Research into branch predictors~\cite{godbolt2016branch}, cache replacement
policies, and reorder buffer construction~\cite{measuring-rob} paved the way for
the branch prediction side-channels employed by Spectre (and subsequently
\speculake).
%Efforts to examine cache and memory security also preempted the Spectre work, 
%including Sophia D'Antoine's thesis work developing a side channel based on 
%instruction interleaving in the CPU~\cite{d2015exploiting}. Similar research into branch 
%predictors, cache replacement policies, and reorder buffer construction including work by Matt 
%Godbolt~\cite{godbolt2016branch}, and Henry Wong~\cite{measuring-rob} paved the runway for 
%dedicated branch prodiction side-channels.

% Discovery & Followup
Given the numerous directions that were being investigated in reverse
engineering Intel processors, multiple teams discovered the Spectre
vulnerabilities concurrently~\cite{spectre, project_zero, evtyushkin2018branchscope, maisuradze2018speculose}.
%These works propose multiple variants making use of branch prediction.
Follow 
up work on speculative execution side channels has also demonstrated
web-based vulnerabilites~\cite{genkin2018drive} as well as hardware isolation  
leaks in Intel's SGX~\cite{spectre_sgx}. At the time of writing multiple sources
have claimed new speculative execution related exploits termed \textit{Spectre-NG}
have been reported to Intel and assigned CVE numbers, though details are
not yet available~\cite{spectre_ng_gossip}.
%We have no details
%on content, though Intel has labeled four as critical and another four 
%as intermediate security flaws~\cite{spectre_ng_gossip}.  


% defenses

%Much like cache side channel vulnerabilities speculative execution is relatively
%critical to processor performance and requires significant software and hardware 
%updates to fully address. 
% Multiple measures have been proposed to combat the 
% individual variants of Spectre.

% One popular approach uses compiler level software patches to wrap sensitive 
% function calls. Retpoline replaces indirect jumps with \texttt{retq}
% instructions that read from the cached stack (and are thus less likely to be
% mis-speculated)~\cite{retpoline}.
% Gruss~\textit{et al.} propose the KAISER software patch to enforce address space
% isolation for kernel and user space proceses~\cite{gruss2017kaslr}. 
% Other proposals have considered hypervisor enforced time domain separation at varying 
% granularity~\cite{renau2018securing}, and fuzzy clocks that would reduce the accuracy 
% of any time based exfiltration pathway~\cite{hu1992reducing}. However, none of these defenses
% fundamentally defeat the use of a branch predictor as a cooperative mechanism
% spanning multiple processes. Intel has released microarchitecture updates for
% its most recent CPUs, but older architectures do not support these updates and
% will remain vulnerable~\cite{intel-micro-patch}.


% Trippel~\textit{et al.} proposes a method of faithfully simulating hardware
% bugs, given a formal model specifying the
% microarchitecture~\cite{trippel2018meltdownprime}. However, such models are
% unlikely to be released by CPU manufacturers, as they generally involve
% closely-guarded trade secrets, making this a less accessible solution for the
% research community.

%\smallskip
%
%We can certainly look forward to more vulnerabilities relating to speculative 
%branching and related hardware side channels. Our work represents an exploit 
%model for these vulnerabilities reliant upon shared hardware resources. 



%%%%%%%%%%%%%%
