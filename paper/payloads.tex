
\section{Application Payloads}

While the amount of computation done in a single speculative execution is small,
we demonstrate several applications that can take advantage of multiple
speculative runs to carry out computation.

As a first step, we observe that the speculative primitive can be used to trivially
implement a finite state machine: any logic can be done in the speculative
world, while updates to the state are communicated to the real world where they
are stored. On the next run of the speculative instructions, they read from the
real world state (and other inputs), compute any state transitions, and
communicate the next state. In this mode, the state is maintained by the real world,
while updates are controlled by code executed speculatively.

Next, we observe that the instructions to be executed speculatively can be
obscured further by encrypting them. This encryption allows for hidden
computation, instructions are stored in the real world encrypted, they are then
decrypted in the speculative world and passed to the real world to be executed.
This method makes it appear as though the program is generating its own code.

\FigGeneralModel

\subsection{Turing Machine}
\label{subsec:turing}
To demonstrate that arbitrary computation can be done in the speculative world
we implement a Turing machine, configured to run the 5-state Busy Beaver function~\cite{busy-beaver}.
The Busy Beaver is a configuration that writes the most
1s on the tape with only a limited number of states and still halts.

The computation of the Turing Machine is done speculatively, meaning that while
the real world keeps track of the state, tape, and symbols of the turing machine
all logic used to update the above is done in the speculative world.

\subsection{Unpacking and Decryption}
\label{subsec:decryption}

Section~\ref{subsec:turing} demonstrates that arbitrary speculative computation
is possible, but hiding malware this way has several drawbacks. First, an
analyst might be able to observe that something is driving a Turing
machine by noticing the real world state updating. With enough symbols, the
analyst could reverse engineer the state machine even without being able to see
the internal logic executing speculatively. Second, Turing machines are a
poor choice for practical computation, as they are inefficient and have no direct
way to perform system calls or otherwise interface externally.

We explore a more practical application of using \speculake to perform
decryption speculatively. To hide keys from the analyst, the key and decryption
code only occur in the speculative world, while committed state only learns the
resulting plaintext. Furthermore, the speculative code can
derive the decryption key based entirely off the trigger program, making it
impossible for an analyst that only has the payload program from being able to
determine the key or decrypt the embedded ciphertext.


Any observer watching the execution of this program would never see any
indication of decryption, due to the exploitation of speculative execution. Any
observation of the executed instructions would not include any decryption
instructions, or loading of keys as they are only done speculatively, and thus
not shown in any debugging or real world traces of program execution. 
%Additionally the observer would be unable to find the executed instructions in
%the ELF file as they are only stored encrypted. 

We note that 200 instructions is too short for most software-implemented
cryptography. However, modern Intel CPUs provide hardware support for AES, which
we find only takes a handful of $\mu$-ops to perform the instructions needed in
AES decryption. We discuss details of our speculative AES decryption in
Section~\ref{sec:impl-aes}.

\medskip

We note that an analyst might attempt to locate the speculative entry point by
searching for AES-NI instructions in the payload program's dead code, ultimately
discovering the keys that it uses. However, we find it is possible to overcome
this by having the trigger program communicate the decryption key to the payload
program via the branch predictor.

To accomplish this, we use multiple speculative entry points, each that derive a
different decryption key before calling a common decryption routine. Since
the exact speculative entry point is determined by the trigger program, an
analyst cannot discover the decryption key directly from the payload program.

An analyst could still enumerate all potential entry points, testing each one
until they find one that correctly decrypts the ciphertext. In a 1~MB binary,
there are (at most) only 1~million entry points, providing just 20~bits of
security.

To increase security, we \emph{chain} entry points together. Rather than derive
the key from a single entry point, we have each potential entry point perform
another indirect jump that the CPU cannot immediately resolve, forcing it to
speculate while already executing speculatively. The predicted target of that jump
will also be determined by the trigger program. For example, if the trigger
program makes 30 training jumps, followed by 10 additional indirect jumps, and
the payload program performs the same 30 training jumps before a stall, the CPU
will predict the payload program will also perform the next 10 jumps. If each
jump has the potential to land in up to 1024 possible locations, this would
provide in total $1024^{10} = 2^{100}$ possible keys, or 100~bits of security.
We describe our implementation of this nested speculative execution concept in
Section~\ref{sec:impl-aes}.


%There are numerous challenges for a reverse engineer to overcome to learn how a
%malicious program with this primitive works. As with previous examples, the
%malicious instructions are only executed when the correct trigger program is
%running (priming the jump table predictor \textbf{TK: word for this?}). However,
%when the to-be-executed instructions are executed the reverse engineer cannot
%locate these instructions in the ELF file, or generated source code. These
%instructions (when they even appear) seem to be generated by themselves, with no
%apparent cause. Additionally, there is no indicator that these instructions are
%encrypted as the decryption is done in the speculative world, meaning that no
%decryption (or key interaction) is done in a way visible to a reverse engineer.
%
%This method allows for arbitrary computation that is unobservable to any observer (static or dynamic). 


% 
% Argument for obfuscating keyschedule
% 
% Challenge for Rev-Engineer
%   - Find the obfuscated key schedule
%   - Find the correct trigger program

\subsection{Virtual Machines}
Given the specific constraints that the speculative environment enforces on
these payloads, general purpose computation []. We demonstrated in
Section~\ref{subsec:turing} that general purpose computation is possible using
computation performed in the speculative environment. However, a turing machine
is not a user friendly model, nor is it an efficient model for computation when
attempting to accomplish tasks on modern processors. 

Using emulators in the "real world" allows for crafted binary programs to be
instrumented in dead code and, as demonstrated in
Section~\ref{subsec:decryption} encrypted and hidden. This gives an advantage to
attackers as traditional reverse engineering methods will reveal only that
emulation is being done. It reveals nothing about the ultimate goal of the
program. 

To accommodate both developers as well as the unique constraints 
enforced by the speculative primitive, a custom emulation solution is required. We 
have approached this challenge from both directions. First we demonstrate 
general purpose emulation using a custom instruction set -- SPASM -- which
accommodates the speculative primitive specifically. Next we investigate custom 
wrappers on traditional emulators allow for similar payload construction,
with a much more developer friendly 

% REFERENCE FIGURES
% - Constraints enforced by speculative primitive
%       - more bits = slower
%       - less bits = less expressive
%       - must be computable within speculative ROB limit (~150 instrs) (decrypt only)
%   
% - optimizations for weird-machine computations 

% --- VM
%   - Wrappers around traditional ISA VMs
%   - SPASM  custom emulator made f
%%%%%%%%%%%%%%
