
\section{Application Payloads}

While the amount of computation done in a single speculative execution is small,
we demonstrate several applications that can take advantage of multiple
speculative runs to carry out computation.

As a first step, we observe that the speculative primitive can be used to trivially
implement a finite state machine: any logic can be done in the speculative
world, while updates to the state are communicated to the real world where they
are stored. On the next run of the speculative instructions, they read from the
real world state (and other inputs), compute any state transitions, and
communicate the next state. In this mode, the state is maintained by the real world,
while updates are controlled by code executed speculatively.

Next, we observe that the instructions to be executed speculatively can be
obscured further by encrypting them. This encryption allows for hidden
computation, instructions are stored in the real world encrypted, they are then
decrypted in the speculative world and passed to the real world to be executed.
This method makes it appear as though the program is generating its own code.

\FigGeneralModel

\subsection{Turing Machine}
\label{subsec:turing}
To demonstrate that arbitrary computation can be done in the speculative world
we implement a Turing machine, configured to run the 5-state Busy Beaver 
function~\cite{chaitin1987computing,herken1992universal}.
The Busy Beaver is a configuration which writes the most
1s on the tape before halting with a limited number of states.

The computation of the Turing Machine is done speculatively, meaning that while
the real world keeps track of the state, tape, and symbols of the turing machine
all logic used to update the above is done in the speculative world.

\subsection{Unpacking and Decryption}
\label{subsec:decryption}

While a Turing machine demonstrates that arbitrary speculative computation
is possible, hiding malware this way has several drawbacks. First, an
analyst might be able to observe that something is driving a Turing
machine by noticing the real world state updating. With enough symbols, the
analyst could reverse engineer the state machine even without being able to see
the internal logic executing speculatively. Second, Turing machines are a
poor choice for practical computation, as they are inefficient and have no direct
way to perform system calls or otherwise interface externally.

We explore a more practical application of using \speculake to perform
decryption speculatively. To hide keys from the analyst, the key and decryption
code only occur in the speculative world, while committed state only learns the
resulting plaintext. Furthermore, the speculative code can
derive the decryption key based entirely off the trigger program, making it
impossible for an analyst that only has the payload program to
determine the key or decrypt the embedded ciphertext.


Any observer watching the execution of this program would never see any
indication of decryption, due to the exploitation of speculative execution. Any
observation of the executed instructions would not include any decryption
instructions, or loading of keys as they are only done speculatively, and thus
not shown in any debugging or real world traces of program execution. 
%Additionally the observer would be unable to find the executed instructions in
%the ELF file as they are only stored encrypted. 

We note that 200 instructions is too short for most software-implemented
cryptography. However, modern Intel CPUs provide hardware support for AES, which
we find only takes a handful of $\mu$-ops to perform the instructions needed in
AES decryption. We discuss details of our speculative AES decryption in
Section~\ref{subsec:impl-aes}.

\medskip


\subsubsection{Nested Speculation}

We explore the ability for the CPU to ``double speculate'', where a stalled
indirect jump while the CPU is speculating causes it to predict the target and
speculate a second time. For instance, suppose a payload program truly jumps to
target A, but the CPU is mistrained by a trigger program that jumps to B, thus
causing the payload program to speculatively execute at B. At B, suppose there
is a second indirect jump, perhaps using the same register as the first jump
(which has still not resolved). If the trigger program jumps to C, the payload
program will speculate a second time and also begin executing code at C.

We find that not all Intel CPUs support nested speculation. For
example, it appears Haswell chips do not speculate while already speculating,
but nonetheless support non-nested \speculake. Both Sandy Bridge (which
preceeded Haswell) and Kaby Lake (which followed Haswell) support nested
speculation.
% Could cut
We leverage this support in Section~\ref{subsec:decryption} to
increase the security of speculative decryption keys.

%There are numerous challenges for a reverse engineer to overcome to learn how a
%malicious program with this primitive works. As with previous examples, the
%malicious instructions are only executed when the correct trigger program is
%running (priming the jump table predictor \textbf{TK: word for this?}). However,
%when the to-be-executed instructions are executed the reverse engineer cannot
%locate these instructions in the ELF file, or generated source code. These
%instructions (when they even appear) seem to be generated by themselves, with no
%apparent cause. Additionally, there is no indicator that these instructions are
%encrypted as the decryption is done in the speculative world, meaning that no
%decryption (or key interaction) is done in a way visible to a reverse engineer.
%
%This method allows for arbitrary computation that is unobservable to any observer (static or dynamic). 


% 
% Argument for obfuscating keyschedule
% 
% Challenge for Rev-Engineer
%   - Find the obfuscated key schedule
%   - Find the correct trigger program

\subsection{Virtual Machines}
We demonstrate in Section~\ref{subsec:turing} that general purpose computation 
is possible in the speculative environment in spite of the constraints 
imposed. However, a Turing Machine
is not an efficient or usable model for computation when
attempting to accomplish tasks on modern processors. 

Using emulators in the ``real world'' allows for binary programs to be
placed encrypted and hidden in dead code and, as demonstrated in
Section~\ref{subsec:decryption}.
Traditional reverse engineering methods will reveal only that
emulation is being done, while the program being emulated remains encrypted.
Even when the trigger is running, only the parts of the code that execute would
be revealed to a careful analyst observing the CPU's committed state, and the
remainder of the emulated program would remain hidden.

We design a custom emulator and instruction set---SPASM (Speculative
Assembly)---that accommodates the constraints of the speculative primitive.
SPASM is a 6-bit Instruction set, where all instructions (including operand,
registers, and arguments) fit within 6-bits. This allows each step of the
speculative world to emit a single SPASM instruction to the real world for
emulation by a light-weight SPASM emulator. Using SPASM, developers can write
programs, assemble and encrypt them into a payload program. When the
associated trigger program runs, the payload will decrypt SPASM instructions in
the speculative world, and execute them one at a time.


% The assembly level abstraction that SPASM provides is still not extremely
% user friendly as it does not allow an author to write their encrypted 
% emulator payload in a high level language.  

While the custom emulator that we developed gives higher level abstraction to
an author, it still requires programs to be written in a custom assembly language. 
We note that the \speculake model is not intrinsically linked to the SPASM emulator. 
A wrapper could be implemented around other existing emulators to construct
instructions incrementally through the fixed-width channel (e.g. using 4 8-bit
reads to reveal a single 32-bit ARM instruction).
This would allow for encrypted payloads to be written in higher level languages
like C or C++, and compiled to any target architecture the real-world emulator
can execute.
