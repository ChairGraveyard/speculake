\documentclass[sigconf, anonymous]{acmart}

\fancyhf{} % Remove fancy page headers 
\fancyhead[C]{Specpiler} % TODO: replace 9999 with your paper number
\fancyfoot[C]{\thepage}

\setcopyright{none} % No copyright notice required for submissions
%\acmConference[Anonymous Submission to ACM CCS 2018]{ACM Conference on Computer and Communications Security}{Due 08 May 2018}{Toronto, Canada}
\acmYear{2017}

\settopmatter{printacmref=false, printccs=true, printfolios=true} % We want page numbers on submissions

%%\ccsPaper{9999} % TODO: replace with your paper number once obtained

\newcommand{\speculake}{SpecPiler}


\begin{document}
\title{\speculake: Hiding Malware in Speculative Execution} % TODO: replace with your title

\begin{abstract}
Recently, the Spectre and Meltdown attacks have revealed serious vulnerabilities in modern CPU
designs, allowing an attacker to exfiltrate data from sensitive programs. These
vulnerabilities take advantage of speculative execution to coerce a processor to
perform computation that would otherwise not occur, leaking the resulting
information via side channels to an attacker.

In this paper, we extend these ideas in a different direction, and leverage speculative
execution in order to \emph{hide malware} from both static and dynamic analysis. Using this
technique, large portions of a malware's computation can be shielded from view,
such that even a debugger following an instruction-level trace of the
program cannot tell how its results were computed.

We introduce \emph{\speculake}, which compiles arbitrary malicious code into a
seemingly-benign payload binary. When a separate trigger program performs a specific
pattern of indirect jumps, it (mis)trains the CPU's branch predictor. Subsequent
executions of the payload binary with similar jumps leads the CPU to mispredict its
branches and speculatively execute the malware's payload, which communicates
results back to the real world via side channels.

We study the extent and types of execution that can be performed in the
``speculative world'', and build tools that enable several computations to be
performed covertly. In particular, within speculative execution we are able to
decrypt memory using AES-NI instructions, and are able to interpret a custom
virtual machine language to perform arbitrary computation.
We also show how the trigger program
can be a pre-existing benign application already running on the system, and
demonstrate this concept with OpenSSL driven remotely by the attacker as our
trigger program.

Finally, we describe defenses, but in all honesty, you're probably not going to like
them.

\end{abstract}

% TODO: replace this section with code generated by the tool at https://dl.acm.org/ccs.cfm

%\begin{CCSXML}
%<ccs2012>
%<concept>
%<concept_id>10002978.10003029.10011703</concept_id>
%<concept_desc>Security and privacy~Usability in security and privacy</concept_desc>
%<concept_significance>500</concept_significance>
%</concept>
%</ccs2012>
%\end{CCSXML}

%\ccsdesc{Security and privacy~Use https://dl.acm.org/ccs.cfm to generate actual concepts section for your paper}
% -- end of section to replace with generated code

\keywords{Malware; TK; TK} % TODO: replace with your keywords

\maketitle

%%%%%%%%%%%%%%
\section{Introduction}


%%%%%%%%%%%%%%
\section{Background}

\subsection{Speculative Execution}
-CPU pipelines -> Branch predictors

\subsection{Branch Prediction}
- direct vs indirect
- BHB, BTB

\subsection{Spectre}
- Basic direct branch
- Indirect branch predictor


%%%%%%%%%%%%%%
\section{Architecture}

Two parts: payload program, and trigger program. Could be combined, but need not
be. Describe high-level concept of parts


\subsection{Limits of Speculative Execution}
- Limits of speculative execution (number of instructions)
- Experiment w/ graph of number of instructions
- Limitation is in the ROB

\subsection{Speculative Primitive}
- Primitive: Perform several hundred arbitrary instructions in the speculative
world, then return fixed-length value to the real world.




%%%%%%%%%%%%%%
\section{Application Payloads}

Given the speculative primitive, what can we do with it?

Finite state machine...

\subsection{Turing Machine}
- Arbitrary computation

\subsection{Unpacking and Decryption}
- AES instructions

\subsection{Virtual Machine}


%%%%%%%%%%%%%%
\section{Trigger Programs}
Easy answer: custom program that mistrains branch predictor

\subsection{Benign Triggers}
Could also be any program on the system, and potentially remote!




%%%%%%%%%%%%%%
\section{Implementation and Evaluation}

\subsection{Turing Machine}

\subsection{AES Decryption}

\subsection{Virtual Machine}

\subsection{OpenSSL Trigger}


%%%%%%%%%%%%%%
\section{Discussion}


\subsection{Defenses}


\subsection{Future Work}





%%%%%%%%%%%%%%
\section{Related Work}


%%%%%%%%%%%%%%
\section{Conclusion}


\bibliographystyle{ACM-Reference-Format}
\bibliography{paper}

\end{document}
