\documentclass[sigconf, anonymous]{acmart}

\fancyhf{} % Remove fancy page headers 
\fancyhead[C]{Specpiler} % TODO: replace 9999 with your paper number
\fancyfoot[C]{\thepage}

\setcopyright{none} % No copyright notice required for submissions
%\acmConference[Anonymous Submission to ACM CCS 2018]{ACM Conference on Computer and Communications Security}{Due 08 May 2018}{Toronto, Canada}
\acmYear{2017}

\settopmatter{printacmref=false, printccs=true, printfolios=true} % We want page numbers on submissions

%%\ccsPaper{9999} % TODO: replace with your paper number once obtained

\newcommand{\speculake}{Exspectre}


\begin{document}
\title{\speculake: Hiding Malware in Speculative Execution} % TODO: replace with your title

\begin{abstract}
Recently, the Spectre and Meltdown attacks have revealed serious vulnerabilities in modern CPU
designs, allowing an attacker to exfiltrate data from sensitive programs. These
vulnerabilities take advantage of speculative execution to coerce a processor to
perform computation that would otherwise not occur, leaking the resulting
information via side channels to an attacker.

In this paper, we extend these ideas in a different direction, and leverage speculative
execution in order to \emph{hide malware} from both static and dynamic analysis. Using this
technique, large portions of a malware's computation can be shielded from view,
such that even a debugger following an instruction-level trace of the
program cannot tell how its results were computed.

We introduce \emph{\speculake}, which compiles arbitrary malicious code into a
seemingly-benign payload binary. When a separate trigger program performs a specific
pattern of indirect jumps, it (mis)trains the CPU's branch predictor. Subsequent
executions of the payload binary with similar jumps causes the CPU to mispredict its
branches and speculatively execute the malware's payload, which communicates
results back to the real world via side channels.

We study the extent and types of execution that can be performed in the
``speculative world'', and build tools that enable several computations to be
performed covertly. In particular, within speculative execution we are able to
decrypt memory using AES-NI instructions, and are able to interpret a custom
virtual machine language to perform arbitrary computation.
We also show how the trigger program
can be a pre-existing benign application already running on the system, and
demonstrate this concept with OpenSSL driven remotely by the attacker as our
trigger program.

Finally, we describe defenses, but in all honesty, you're probably not going to like
them.

\end{abstract}

% TODO: replace this section with code generated by the tool at https://dl.acm.org/ccs.cfm

%\begin{CCSXML}
%<ccs2012>
%<concept>
%<concept_id>10002978.10003029.10011703</concept_id>
%<concept_desc>Security and privacy~Usability in security and privacy</concept_desc>
%<concept_significance>500</concept_significance>
%</concept>
%</ccs2012>
%\end{CCSXML}

%\ccsdesc{Security and privacy~Use https://dl.acm.org/ccs.cfm to generate actual concepts section for your paper}
% -- end of section to replace with generated code

\keywords{Malware; TK; TK} % TODO: replace with your keywords

\maketitle

%%%%%%%%%%%%%%
\section{Introduction}


%%%%%%%%%%%%%%
\section{Background}
Modern CPU designs employ a wide range of tricks in order to maximize
performance. In this section, we provide preliminary background as they are
relevant to our system, as well as a brief summary of the Spectre vulnerability.

\subsection{Out-of-Order Execution}
Many CPUs attempt to keep the pipeline full by executing instructions \emph{out of
order}, with the CPU allowing future instructions to be worked on and executed
while it waits for slower or stalled instructions to complete. To maintain
correctness and the original (Von Neumann) ordering, instructions are tracked in
a \emph{reorder buffer} (ROB), which keeps the order of instructions as they are
worked on out of order. Instructions are \emph{retired} from the ROB when
they are completed and there are no previous instructions that have yet to
retire. Upon retiring, an instruction's results are committed to the architectural
state of the CPU. Thus, the ROB ensures that the program (or debugger) view
of the CPU state always updates in program execution order, despite out of order
execution.

\subsection{Speculative Execution}

CPUs also attempt to keep their pipeline full by predicting the path of
execution. For example, a program may contain a branch that depends on a result
from a prior slow instruction. Rather than wait for the result, the CPU can
\emph{speculatively execute} instructions down one of the paths of a branch,
storing the results of the speculative instructions in the ROB.
If the guess of the branch target turns out to be correct, the CPU can quickly
retire all the instructions it has speculatively executed while waiting. If the
guess is incorrect, the CPU must discard the
(incorrectly) speculated instructions from the ROB, and continue executing from the
correct branch target.


\subsection{Branch Prediction}
When a CPU mispredicts a branch, the speculative execution results are
discarded, costing the CPU several cycles as the pipeline is flushed. To
minimize this, CPUs employ \emph{branch predictors} that attempt to guess the
path of execution. Branch predictors maintain a short history of previous
branch targets for a particular branch (e.g. whether a certain branch is
frequently taken or not taken), and use
this to inform the CPU's guess for speculative execution.

There are two kinds of branches a CPU handles: \emph{direct} and
\emph{indirect}. A \emph{direct} branch may either jump to a provided address or
continue executing straight through depending on the state of the CPU (e.g. condition
registers). While there are only two potential statically-known targets for a direct
branch, the CPU may not know if the branch is taken or not until preceding
instructions retire. An \emph{indirect} branch is always taken, but its address
is determined by the value of a register or memory address. Direct branches are
typically used for control flow such as \texttt{if} or
\texttt{for}/\texttt{while} statements, while indirect branches are used for
function pointers, class methods, or case statements.


%- BHB, BTB

\subsection{Spectre}
In early 2018, researchers revealed the Spectre vulnerability, which allows an
attacker to leak information from a victim program.

Spectre uses speculative execution...
- Basic direct branch
- Indirect branch predictor


%%%%%%%%%%%%%%
\section{Architecture}

\speculake malware is comprised of two independent programs: a payload program, and a
trigger program. Both are installed on the victim's computer (e.g. via trojan, remote
exploit, or phishing), a

Two parts: payload program, and trigger program. Could be combined, but need not
be. Describe high-level concept of parts


\subsection{Limits of Speculative Execution}
- Limits of speculative execution (number of instructions)
- Experiment w/ graph of number of instructions
- Limitation is in the ROB

\subsection{Speculative Primitive}
- Primitive: Perform several hundred arbitrary instructions in the speculative
world, then return fixed-length value to the real world.




%%%%%%%%%%%%%%
\section{Application Payloads}

Given the speculative primitive, what can we do with it?

Finite state machine...

\subsection{Turing Machine}
- Arbitrary computation

\subsection{Unpacking and Decryption}
- AES instructions

\subsection{Virtual Machine}


%%%%%%%%%%%%%%
\section{Trigger Programs}
Easy answer: custom program that mistrains branch predictor

\subsection{Benign Triggers}
Could also be any program on the system, and potentially remote!




%%%%%%%%%%%%%%
\section{Implementation and Evaluation}

\subsection{Turing Machine}

\subsection{AES Decryption}

\subsection{Virtual Machine}

\subsection{OpenSSL Trigger}


%%%%%%%%%%%%%%
\section{Discussion}


\subsection{Defenses}


\subsection{Future Work}





%%%%%%%%%%%%%%
\section{Related Work}


%%%%%%%%%%%%%%
\section{Conclusion}


\bibliographystyle{ACM-Reference-Format}
\bibliography{paper}

\end{document}
