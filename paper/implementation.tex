
\section{Implementation and Evaluation}
We now discuss the details of our implementations and the information learned
about speculative execution gained by these experiments. We discuss how we gain
confidence in information passed back, and how a low number of iterations is
sufficient to gain a strong confidence in results.

\subsection{Turing Machine}
\label{subsec:impl-turing}

We implemented a 5-state Busy Beaver Turing machine.
This implementation led to the discovery of many of the limitations and
capabilities of speculative execution.

We found that our implementation is able to examine the state and current symbol
on the Turing tape and make decisions based on these values as long as they are
in cache. The subtlety here is that in order to enter this speculative execution
the function pointer must be flushed from cache (causing the branch predictor to
incorrectly predict the target function as the destination). As such, care must
be taken to ensure that the function pointer and state to be used in the
speculative execution must be in separate cache lines. 

In our model the real world keeps track of the Turing state and tape. The
speculative world uses this information to load a specific value into cache. The
real world then times the loading of these values to determine which value was
loaded speculatively. This value is then used to update the state and tape and
the process is repeated until a halt state is reached.

In order to have confidence the value loaded speculatively is correct we repeat
the execution a number of times and look for the value that has the quickest
real-world load time over each repetition, whichever value is quickest to load
the most is then determined to be the ``correct'' value.

Our Turing implementation discovered that only 50 repetitions is sufficient for
the real world to determine the correct value with over 80\% confidence.

We implemented the 5 state Busy Beaver configuration which requires over 47
million steps to complete. We were able to verify that the speculative world
could correctly compute 20 thousand steps with no errors.

% Target_fn returning next step given access to current state in global vars
%   - busy beaver
%   - cache page speculation on repetetive cycles. 
%       - mis-predict w/in speculative world 

% speed (complete smaller busy beaver?)
% against reference python implementation?

\subsection{AES Decryption}
\label{subsec:impl-aes}
The speculative world is able to take advantage of the AES-NI instructions to
decrypt messages. In order to avoid detection (as well as reduce the computation
that needs to be done in the speculative world) the key expansion can be done
ahead of time. However, the key schedule does have a structure that could be
detected by a reverse engineer. Thus 11 random round keys are selected. This
obfuscated key schedule makes it more difficult for a reverse engineer to
determine that there is encrypted content. Additionally since the content is
only accessed when the correct trigger program is running the challenges facing
a reverse engineer are great. We discuss further methods for obfuscating
specualtive decryption in section~\ref{subsec:future-work}. 


We have implemented the AES decryption as a fundamental piece of the \speculake model,
and we demonstrate that the speed at which information can be decrypted using the speculative 
primitive is dependent on the configuration of the \speculake model. Specifically,
the channel width and the required minimum signal strength determine the maximum
throughput that can be achieved. As demonstrated in Figure~\ref{fig:spec_bandwidth} 
between 6 and 8 bits channel width provides an idea of the maximum speed at which the 
speculative primitive can be used with AES-NI instructions in the payload. 

While the \speculake model acheives only moderate decryption speed, the 
critical computation of the decryption is done in the speculative world. 

\FigSpecBandwidth

\subsection{Virtual Machine}
\label{subsec:spasm}

% \subsubsection{SPASM}
% \label{subsubsec:spasm}
Constructing an emulator making use of the speculative primitive requires  
a trade off in expresive capability versus speed. 
We have implemented SPASM as a model using two pseudo-registers, and six 
bit instruction length which allows for a relatively direct programming model 
in which structured values can be entered into memory locations before making 
a systemcall.

To acheive a balance with speed the number of bits in each instruction is both 
fixed and minimized.  A variable length instruction would require that the 
\texttt{Flush+Reload} stage search the maximum number of bits on each round, and each 
aditional bit doubles the search space that the \texttt{Flush+Reload} stage must 
traverse.  So every bit shorter effectively doubles the throughput of the 
emulator, and there is effectively no advantage to allowing variable length 
instructions. Details of the SPASM instruction set can be found in 
Appendix~\ref{appendix:spasm}. 

Using this model we have implemented multiple example programs that can be run
as encrypted binaries in an \speculake payload. A \textit{HelloWorld} program 
that prints to stdout. A \textit{FizzBuzz} program that demonstrates control 
flow and arithmetic operations while printing to stdout. And finally,
a \textit{ReverseShell} program that opens and connects to a socket before  
duplicating I/O file descriptors and executing a local shell. 

Expected performance for a given SPASM binary will vary given multiple factors, 
the most important of which is the \texttt{Flush+Reload} redundancy. This can be tuned
based on the specific trigger, as it is used to establish confidence that a signal 
has been identified in the indicess returned from the "speculative world". 
%Thus accomplishing a task using SPASM generally equates to:

% \begin{lstlisting}
%     Redundancy * Probe_Space * Num_Instr
% \end{lstlisting}

For example, the \textit{ReverseShell} program makes six system calls to open a socket,
connect to it, duplicate I/O file descriptors, and perform an execve
systemcall to open a shell. This requires 355 SPASM instructions to complete. 
The probe space for the 6-bit SPASM ISA requires a traversal of an array of size 64.
When using a redundancy of 256 to establish confidence in the signal the entire 
\textit{ReverseShell} program takes under 7 seconds to run once triggered. 


% TODO - REFERENCE APPENDIX for ISA

\FigSpasmModel

\subsection{OpenSSL Trigger}
\label{subsec:openssl}

Benign programs can act as a trigger program, provided they perform sufficient
indirect jumps to train the branch predictor. We experiment using the OpenSSL
library as a potential benign trigger, as its source code has gratuitous use of
function pointers which compile to indirect jumps. In addition, it has many
complicated code paths that can be easily selected by remote clients by their
choice of cipher suite.

For these experiments, we disable ASLR for simplification, but note that the
branch predictors can be used to determine ASLR offsets and our attack adjusted
accordingly~\cite{evtyushkin2016jump}.

We used \texttt{gdb} to run an instance of an OpenSSL server (version 1.0.1f),
and printed out every instruction executed and its address after a breakpoint on
the \texttt{SSL\_new} function. We then made a TLS connection to the
server\footnote{Which took well over 2~hours, potentially making it the slowest
TLS handshake to have ever completed},
which produced over 13~million instructions, including over 359,000 direct jumps
and 28,000 indirect jumps. We then searched for the longest repeated set of over
30 indirect jumps that end with a unique jump (i.e. source and destination do
not occur in the previous 30 indirect jumps).

We discovered a candidate that corresponds to code in OpenSSL's
\texttt{nistp256.c} that contained 31 indirect jumps repeated 254 times in our
handshake. This code is used during the TLS key exchange as the server computes
the ECDHE shared secret. We made a list of 31 source-destination address pairs
for these indirect jumps, and constructed a jump/ret chain at those addresses in
our payload program. Our program would jump to the source address of a pair,
which had a single \texttt{retq} instruction, which would pop the next
destination off the stack and perform the indirect jump. At each destination
address, we placed a static (direct) \texttt{jmpq} to bring execution to the
next source address in our list. The final jump source/destination pair was not
performed (and the destination was not pushed to the stack). However, we placed
code at the destination address that loaded a value into the cache (our target
function). The last pair's source performs an indirect jump that returns to our
payload program, which immediately times probing the cache to see if any value was
loaded.

We ran these experiments on an Intel Haswell
i5-4590 CPU, with OpenSSL and our payload program taskset to the same core.
We induced the jump pattern in OpenSSL by running Apache benchmark against it to
generate thousands of connections, using the ECDHE key exchange with the
secp256r1 curve (ECDHE-RSA-AES256-GCM-SHA384). When running Apache benchmark locally, our payload program
reliably achieves a 3.5\% hit rate. When apache benchmark runs on a remote
machine, the hit rate drops to approximately 2.0\%. Nonetheless, this is
sufficient to perform computation, as we simply perform thousands of iterations
to extract results from the speculative world before updating any real world state.

We verified that our payload program did not observe any cache loads when we ran
other programs that consumed CPU on the same core. In addition, when we used
Apache benchmark to create thousands of connections with a different cipher
suite (DHE-RSA-AES128-GCM-SHA256), we similarly received no hit rate. This
could potentially allow an adversary to use an obscure or uncommon (but still
supported) cipher suite to trigger a malicious payload program on a remote server.



\subsection{Nested Speculation}
\label{subsec:nested-spec}

%%%%%%%%%%%%%%
