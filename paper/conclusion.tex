
\section{Conclusion}

In this paper we present \speculake, a model for hiding computation in speculative 
execution that is fundamentally different than modern methods of obfuscating 
computation. Through a series of experiments we have classified the 
capabilities and limitations of this speculative primitive and demonstrated 
various example applications. The flexibility in these applications stemming 
from the general computation permitted speculatively allows for emulation, 
transparent and remote communication, and process level data encryption.  
As a result current analysis techniques for detecting process cooperation, 
and describing the behavior of program
binaries are no longer definitively reliable. 

Given the parameters of the speculative primitive described in this work and
the benefits that speculative execution provides to an attacker, the 
feasability of an \speculake exploit is unfortunately high and is not limited 
to data side-channels or process isolation violations. The speculative primitive 
developed in this work not only provides a guarded form of 
computation, but also enables cryptographic protection against current
analysis and debugging techniques.  

Software isolation techniques are critical in protecting against exploitation 
models, however, complex optimization has often neglected these principles in 
favor of performance. The stop-gap measures proposed in this work contain 
security and performance trade-offs, though we advocate for a more robust 
solution in future processor generations. Long term
solutions may require that we take a step backward before we can 
securely step forward.

