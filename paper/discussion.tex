
\section{Discussion}

\subsection{Defenses}
We now address possible defenses to this new class of malware introduced by
\speculake. Though we caution that these defenses often have drawbacks. The core
component of \speculake is taking advantage of speculative execution inherent in
CPUs today, thus these defenses focus on limiting this behavior.


%TODO: This is a defense to Spectre, but not to Exspectre...
\subsubsection{SpecFence}
The \texttt{mfence} instruction requires that instructions earlier in the code
be retired before instructions after it. This ensures that memory is loaded and
stored in a particular order (in the real world). However, the \texttt{mfence}
instruction can be speculated past, meaning that caches can be affected
out-of-order even with this instruction.

One possible defense against \speculake is the introduction of a new
instruction: \texttt{specfence} which designates to the CPU a point that cannot 
be speculated past. This would require that loads/stores after the 
\texttt{specfence} instruction would be on hold until loads/stores from before
the \texttt{specfence} instruction have retired. Note the subtle difference from
\texttt{mfence}, we not only require that the loads/stores before a
\texttt{specfence} retire ahead of the loads/stores after the 
\texttt{specfence}, but more strongly: the loads/stores after a 
\texttt{specfence} do not begin to execute at all until the loads/stores before
the \texttt{specfence} retire.

This would possibly require a set of new API instructions in most basic
libraries allowing for functions that ensure no speculation (for security, no
data is leaked, no mystery instructions are run) and a separate set of functions
(as exist now) which allow speculation to occur (for performance, no sensitive
data is at risk).

We note that this instruction seems to already exist, albeit unintentionally.
The \texttt{rep} instruction repeats the execution of string instructions a set
number of times (set in a register). When set to repeat 90 or more times, these
instructions are not speculated past, requiring they complete and be retired
before looking to the next instruction. This appears to be due to the 
\texttt{rep} instruction adding additional $\mu$ ops per instruction, we found
that using the \texttt{rep} instruction caused $2n$ $\mu$ ops when the string
operation works on $n$ bytes~\cite{uop_article}. Thus enough repetitions would cause instructions
after the \texttt{rep} instruction to wait for the full repetition to be retired
before beginning their execution.

While this either new or repurposed instruction may provide some defense
against \speculake there are clear drawbacks: 
\begin{enumerate}
    \item Code using this instruction will be slower to execute by design. The
    purpose of this instruction is to deliberately slow the CPU and force it to
    wait. This will lead to a direct trade-off of speed vs. security.

    \item This will require a new set of APIs for basic library functions that
    load and store data. It would be detrimental to require all loads and stores
    never be speculated past, meaning there must be an option for choosing when
    certain loads and stores are not to be speculated past. This comes with all
    the usual drawbacks of modified APIs, un-updated systems, software engineers
    unaware of the new API, or of the significance, or when speculation is
    appropriate and when it is dangerous.
\end{enumerate}

\subsubsection{Malware Detection}
The world of computer security is often referred to as an arms race, hackers and
criminals racing to create and use exploits before security researchers and
software engineers can create defenses. As such we expect to see the same type
of race with this new class of malware. 

A necessary portion of this class of malware is utilizing a cache side-channel,
determining how long certain values require to load from memory or cache. Thus
one method of defense against \speculake is to adapt malware detectors to
examine if a program checks for the timing of loading values from memory. 

Initially this appears to be a very effective method of recognizing this attack.
However, the notion of timing memory loads can be done in obscure ways which can
be made to appear innocuous. As opposed to directly measuring the timing of
memory loads, the timing can be more indirect: measuring how long a specific
loop takes that happens to do a memory load. Or more directly, avoiding
measuring time altogether: create a race-condition which only the
already-in-cache value will easily win.

While the notion of simply adapting current defenses to recognize this new
strain of malware may be simplest, we caution that the methods introduced by
\speculake are very general and can be accomplished in numerous ways and simply
attempting to recognize one method will undoubtedly be circumvented by future
generations of this malware.

\subsection{Future Work}
\label{subsec:future-work}


%\subsubsection{Full Whitebox Cryptography}
%To make it difficult to extract the key schedule used to decrypt the ciphertext,
%we can preload a large block of random data, and have multiple speculative entry
%points, each that choose a different index into the random data to be used as
%the key schedule, and then jumps to a common decryption routine. This way, the exact
%speculative entry point determines the key used for decryption. Because the
%exact speculative entry point is determined by the trigger program, an analyst
%cannot discover the decryption key directly from the payload program.
%
%An analyst could enumerate potential entry points, and test each one
%until they find one that correctly decrypts the ciphertext. In a 1~MB binary,
%there are (at most) only about 1~million entry points, providing just 20~bits of
%security.
%
%To increase security, we could \emph{chain} entry points together. Rather than
%derive the index from the entry point, we have each potential entry point perform
%another indirect jump that the CPU cannot immediately resolve, forcing it to 
%speculate, inside the speculative world. The predicted
%target of that jump will also be determined by the trigger program. For
%instance, if the trigger program makes 30 training jumps, followed by 10
%additional jumps, the payload program will follow all 40 jumps, with the
%locations of the last 10 jumps used to determine the key index information.
%If each jump could land in up to 1024 possible locations, this would provide in
%total $1024^10 = 2^100$ possible keys, or 100~bits of security.
%
%A payload can still be crafted to use a benign program, given that it 
%implements a sufficient series of jumps. Even if a reverse engineer 
%gets to watch the program run they will only find out the plain text 
%and not the key schedule as any attempts to observe the decryption 
%process will interfere with the speculative branching. The reverse enginner 
%must either identify the exact process that was running concurently 
%which trained the branch predictor, or identify the correct series of 
%jumps taken speculatively to derive the key schedule. 
%
%We believe that the state explosion provided in both of these scenarios 
%presents new and difficult challenges for reverse engineers. 


\subsubsection{Multiple Triggers}
To create further difficulties for a reverse engineer, or to further target
the execution environment it is possible
to have the payload program test a series of separate jump patterns. The decryption
process can then be done in stages where the result of a given stage determines 
the initial state of the next decryption stage that the payload program 
performs. Only when all triggers have been completed in the correct order will
the true plaintext be available. 

While this would increase the difficulty for analyst  who has access
to a sample in isolation, it  does not add any extra layers of complication 
for an analyst who can observe the entire decryption process. Any state 
encoded in the real world during the individual stages will be available to current 
debugging tools. This allows the initial state of a sample to be modified
to simplify subsequent runs. For example, they could patch the 
binary to begin with the state of the final stage such that only the final 
trigger must be run again to retreive the plaintext. While this simplifies the 
job of acquiring the plaintext of a given \speculake sample, it does not give any 
information about the trigger programs or the key schedules used. 


%%%%%%%%%%%%%%
