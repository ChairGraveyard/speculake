
\section{Discussion}

\subsection{Defenses}
We now address possible defenses to this new class of malware introduced by
\speculake. Though we caution that these defenses often have drawbacks. The core
component of \speculake is taking advantage of speculative execution inherent in
CPUs today, thus these defenses focus on limiting this behavior.


%TODO: This is a defense to Spectre, but not to Exspectre...
\subsubsection{SpecFence}
The \texttt{mfence} instruction requires that instructions earlier in the code
be retired before instructions after it. This ensures that memory is loaded and
stored in a particular order (in the real world). However, the \texttt{mfence}
instruction can be speculated past, meaning that caches can be affected
out-of-order even with this instruction.

One possible defense against \speculake is the introduction of a new
instruction: \texttt{specfence} which designates to the CPU a point that cannot 
be speculated past. This would require that loads/stores after the 
\texttt{specfence} instruction would be on hold until loads/stores from before
the \texttt{specfence} instruction have retired. Note the subtle difference from
\texttt{mfence}, we not only require that the loads/stores before a
\texttt{specfence} retire ahead of the loads/stores after the 
\texttt{specfence}, but more strongly: the loads/stores after a 
\texttt{specfence} do not begin to execute at all until the loads/stores before
the \texttt{specfence} retire.

This would possibly require a set of new API instructions in most basic
libraries allowing for functions that ensure no speculation (for security, no
data is leaked, no mystery instructions are run) and a separate set of functions
(as exist now) which allow speculation to occur (for performance, no sensitive
data is at risk).

We note that this instruction seems to already exist, albeit unintentionally.
The \texttt{rep} instruction repeats the execution of string instructions a set
number of times (set in a register). When set to repeat 90 or more times, these
instructions are not speculated past, requiring they complete and be retired
before looking to the next instruction. This appears to be due to the 
\texttt{rep} instruction adding additional $\mu$ ops per instruction, we found
that using the \texttt{rep} instruction caused $2n$ $\mu$ ops when the string
operation works on $n$ bytes~\cite{uop_article}. Thus enough repetitions would cause instructions
after the \texttt{rep} instruction to wait for the full repetition to be retired
before beginning their execution.

While this either new or repurposed instruction may provide some defense
against \speculake there are clear drawbacks: 
\begin{enumerate}
    \item Code using this instruction will be slower to execute by design. The
    purpose of this instruction is to deliberately slow the CPU and force it to
    wait. This will lead to a direct trade-off of speed vs. security.

    \item This will require a new set of APIs for basic library functions that
    load and store data. It would be detrimental to require all loads and stores
    never be speculated past, meaning there must be an option for choosing when
    certain loads and stores are not to be speculated past. This comes with all
    the usual drawbacks of modified APIs, un-updated systems, software engineers
    unaware of the new API, or of the significance, or when speculation is
    appropriate and when it is dangerous.
\end{enumerate}

\subsubsection{Malware Detection}
The world of computer security is often referred to as an arms race, hackers and
criminals racing to create and use exploits before security researchers and
software engineers can create defenses. As such we expect to see the same type
of race with this new class of malware. 

A necessary portion of this class of malware is utilizing a cache side-channel,
determining how long certain values require to load from memory or cache. Thus
one method of defense against \speculake is to adapt malware detectors to
examine if a program checks for the timing of loading values from memory. 

Initially this appears to be a very effective method of recognizing this attack.
However, the notion of timing memory loads can be done in obscure ways which can
be made to appear innocuous. As opposed to directly measuring the timing of
memory loads, the timing can be more indirect: measuring how long a specific
loop takes that happens to do a memory load. Or more directly, avoiding
measuring time altogether: create a race-condition which only the
already-in-cache value will easily win.

While the notion of simply adapting current defenses to recognize this new
strain of malware may be simplest, we caution that the methods introduced by
\speculake are very general and can be accomplished in numerous ways and simply
attempting to recognize one method will undoubtedly be circumvented by future
generations of this malware.

\subsection{Future Work}
\label{subsec:future-work}

This work demonstrates a general model for hiding execution in 
the speculative world and examines the implications and limitations on 
Intel processors. Given the wide-spread nature of the Spectre vulnerability 
and the ubiquity of cache side-channels we believe that this work can 
be directly extended to AMD, ARM, and other processors making use of
speculative branch prediction.

\subsubsection{Multiple Triggers}
To create further difficulties for an analyst, or to further target
the execution environment it is possible
to have the payload program test a series of separate jump patterns. The decryption
process can then be done in stages where the result of a given stage determines 
the initial state of the next stage that the payload program 
performs. Only when all triggers have been completed in the correct order will
the true plaintext be available. 

While this would increase the difficulty for analyst  who has access
to a sample in isolation, it  does not add any extra layers of complication 
for an analyst who can observe the entire decryption process. Any state 
encoded in the real world during the individual stages will be available to current 
debugging tools. This allows the initial state of a sample to be modified
to simplify subsequent runs. For example, they could patch the 
binary to begin with the state of the final stage such that only the final 
trigger must be run again to retreive the plaintext. While this simplifies the 
job of acquiring the plaintext of a given \speculake sample, it does not give any 
information about the trigger programs or the key schedules used. 

\smallskip

Alternatively multiple triggers could be used make individual state changes in
the payload program, and write in data from a local, or (as demonstrated in 
section~\ref{subsec:nested-spec}) remote processes. For example, a payload program
can check a series of three distinct jump patterns corresponding to three different 
triggers. If the first trigger is detected the payload shifts in a 1 to the state; if
the second is detected it shifts in a 0. If the third trigger is detected it 
discontinues listening to the three triggers and proceeds with other computation. 
This could be a direct form of \speculake using emulation and decryption 
or more traditional malicious behavior. Using this method a payload program can
be distributed without the encrypted data section all together, instead having 
the data written into the process at run-time without ever connecting out to any 
other resource. 

\subsubsection{Benign Triggers}
We have demonstrated that a using OpenSSL as a benign trigger allows for 
\speculake payloads to be triggered remotely, and discussed the minimum 
requirements for identifying a benign trigger. However, we have not classified
typical system resources that might be used a benign triggers. This is a 
promising direction for future investigation as various system libraries present 
juicy targets for trigger design. For exmaple, if a sufficient series of jumps 
is found to exist in the TCP stack implemented in the unix kernel (i.e. in the TCP
Checksum library) an attacker could reasonably trigger a \speculake payload remotely,
from a spoofed IP address. This attack would rely on a payload defeating KASLR, 
however, this has been demonstrated to be feasible~\cite{gruss2017kaslr,evtyushkin2016jump}

\subsubsection{Alternative Applications}
We have proposed the \speculake model as a new malware threat, however, this model
of hidden computation applies more broadly. As of now there are no ways of 
debugging speculative computation meaning that the computation done there is effectively
isolated as with trusted execution environments. The security provided by the obfuscated 
key schedule makes \speculake useful in the domains of Digital Rights Management (DRM)
and whoitebox cryptography more generally. 
%% Approximate Computing 



%%%%%%%%%%%%%%
