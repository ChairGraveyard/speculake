
\section{Discussion}

\subsection{Defenses}
We now address possible defenses to this new class of malware introduced by
\speculake. Though we caution that these defenses often have drawbacks. The core
component of \speculake is taking advantage of speculative execution inherent in
CPUs today, thus these defenses focus on limiting this behavior.

\subsubsection{Operating System Defenses}
One defense to limit the capabilities of \speculake is to introduce privileged
instructions that grant the Operating System more control. 

A necessary component of \speculake is the ability of a process to affect the
Branch History Buffer (BHB), which is used by all processes, allowing programs
to affect how separate programs choose to make indirect jumps.

To address this a new set of instructions allowing the OS to set and clear the
Branch History Buffer on context switches allows for processes to maintain a
useful branch history while disabling other processes from affecting their jump
decisions.

By design these new instructions grant the operating system control over the
state a program generates introducing possible attack vectors for malicious
Operating Systems to poison the Branch History Buffer or even allow \speculake
type attacks.

\subsubsection{Malware Detection}
\label{subsubsec:malware}
The world of computer security is often referred to as an arms race, hackers and
criminals racing to create and use exploits before security researchers and
software engineers can create defenses. As such we expect to see the same type
of race with this new class of malware. 

A necessary portion of this class of malware is utilizing a cache side-channel,
determining how long certain values require to load from memory or cache. Thus
one method of defense against \speculake is to adapt malware detectors to
examine if a program checks for the timing of loading values from memory. 

Initially this appears to be a very effective method of recognizing this attack.
However, the notion of timing memory loads can be done in obscure ways which can
be made to appear innocuous. As opposed to directly measuring the timing of
memory loads, the timing can be more indirect: measuring how long a specific
loop takes that happens to do a memory load. Or more directly, avoiding
measuring time altogether: create a race-condition which only the
already-in-cache value will easily win.

While the notion of simply adapting current defenses to recognize this new
strain of malware may be simplest, we caution that the methods introduced by
\speculake are very general and can be accomplished in numerous ways and simply
attempting to recognize one method will undoubtedly be circumvented by future
generations of this malware.

\subsubsection{Cache Poisoning}
As mentioned in Section~\ref{subsubsec:malware} a vital component of \speculake
is the ability to perform cache timings. Any mechanism that modifies the cache
can affect the success of \speculake-like attacks. 

Drastic methods such as completely poisoning the cache will hinder this attack
while also forcing almost all loads to result in a cache miss, effectively
nullifying the point of cache.

However, more conservative methods such as randomly loading values into cache
can have a negative affect on \speculake-like attacks (causing the cache timing
to predict incorrect values) while not having too detrimental of an affect on
programs as a whole.

In response to this method of defense \speculake-like attacks can modify the
number of iterations and confidence thresholds necessary to determine a value.
As mentioned in Section~\ref{subsec:impl-turing} our experiments found that it
was only necessary to perform 50 iterations of our \texttt{target\_fn} in order
to gain 80\% confidence in the value returned. While only 50 iterations are
necessary, increasing this value to higher levels can lead to a significantly
higher confidence with very little performance detriment (especially in the
case of AES decryption).

\subsection{Resilience of \speculake}
Spectre works to use a cache side-channel to leak information from a process. As
such defenses to Spectre work to limit the information available to a
speculatively executing program. One such solution may be a new instruction such
as  \texttt{specfence}: an instruction which designates to the CPU a point that
cannot be speculated past. This would require that loads/stores after the
\texttt{specfence} instruction would be on hold until loads/stores from before
the \texttt{specfence} instruction have retired. The loads/stores after a
\texttt{specfence} do not begin to execute at all until the loads/stores before
the \texttt{specfence} retire.

However effective such an instruction may be against Spectre, it is not a
defense against \speculake. Such an instruction would be useful in restricting
the execution of a program to restrict the speculative capabilities of program,
thereby stopping information from being leaked. However, a malicious user
creating \speculake malware would simply choose to not use this instruction.

This demonstrates the versatility of speculative execution in general. While
defenses against Spectre are needed, a more general purpose solution to
speculative execution as a whole is necessary to address the wide range of its
capabilities.

% We note that this instruction seems to already exist, albeit unintentionally.
% The \texttt{rep} instruction repeats the execution of string instructions a set
% number of times (set in a register). When set to repeat 90 or more times, these
% instructions are not speculated past, requiring they complete and be retired
% before looking to the next instruction. This appears to be due to the 
% \texttt{rep} instruction adding additional $\mu$ ops per instruction, we found
% that using the \texttt{rep} instruction caused $2n$ $\mu$ ops when the string
% operation works on $n$ bytes~\cite{uop_article}. Thus enough repetitions would cause instructions
% after the \texttt{rep} instruction to wait for the full repetition to be retired
% before beginning their execution.

\subsection{Future Work}
\label{subsec:future-work}

This work demonstrates a general model for hiding execution in 
the speculative world and examines the implications and limitations on 
Intel processors. Given the wide-spread nature of the Spectre vulnerability 
and the ubiquity of cache side-channels we believe that this work can 
be directly extended to AMD, ARM, and other processors making use of
speculative branch prediction.

\subsubsection{Multiple Triggers}
To create further difficulties for an analyst, or to further target the
execution environment it is possible to have the payload program test a series
of separate jump patterns. The decryption process can then be done in stages
where the result of a given stage determines the initial state of the next stage
that the payload program performs. Only when all triggers have been completed in
the correct order will the true plaintext be available. 

While this would increase the difficulty for analyst  who has access to a sample
in isolation, it  does not add any extra layers of complication for an analyst
who can observe the entire decryption process. Any state encoded in the real
world during the individual stages will be available to current debugging tools.
This allows the initial state of a sample to be modified to simplify subsequent
runs. For example, they could patch the binary to begin with the state of the
final stage such that only the final trigger must be run again to retreive the
plaintext. While this simplifies the job of acquiring the plaintext of a given
\speculake sample, it does not give any information about the trigger programs
or the key schedules used. 

\smallskip

Alternatively multiple triggers could be used make individual state changes in
the payload program, and write in data from a local, or (as demonstrated in
section~\ref{subsec:openssl}) remote processes. For example, a payload program
can check a series of three distinct jump patterns corresponding to three
different triggers. If the first trigger is detected the payload shifts in a 1
to the state; if the second is detected it shifts in a 0. If the third trigger
is detected it discontinues listening to the three triggers and proceeds with
other computation. This could be a direct form of \speculake using emulation and
decryption or more traditional malicious behavior. Using this method a payload
program can be distributed without the encrypted data section all together,
instead having the data written into the process at run-time without ever
connecting out to any other resource. 

\subsubsection{Benign Triggers}
We have demonstrated that a using OpenSSL as a benign trigger allows for
\speculake payloads to be triggered remotely, and discussed the minimum
requirements for identifying a benign trigger. However, we have not classified
typical system resources that might be used a benign triggers. This is a
promising direction for future investigation as various system libraries present
juicy targets for trigger design. For exmaple, if a sufficient series of jumps
is found to exist in the TCP stack implemented in the unix kernel (i.e. in the
TCP Checksum library) an attacker could reasonably trigger a \speculake payload
remotely, from a spoofed IP address. This attack would rely on a payload
defeating KASLR, however, this has been demonstrated to be
feasible~\cite{gruss2017kaslr,evtyushkin2016jump}

\subsubsection{Alternative Applications}
We have proposed the \speculake model as a new malware threat, however, this
model of hidden computation applies more broadly. As of now there are no ways of
debugging speculative computation meaning that the computation done there is
effectively isolated as with trusted execution environments. The security
provided by the obfuscated key schedule makes \speculake useful in the domains
of Digital Rights Management (DRM) and whitebox cryptography, and approximate
computing fields. 
%% Approximate Computing 

Approximate Computing prioritizes the computation of quick results that are
potentially incorrect. This form of computation often leverages some type of
machine learning to determine how well individual results fit with a crowd of
approximately computed results. As mentioned in Section~\ref{subsec:impl-turing}
occasionally values necessary for computation in the speculative world are not
in cache and thus must be speculated themselves. In this situation error
correcting codes are useless given that the mistake is not a mutation of the
correct input, but rather a guess at what the input might be. The mechanisms
used in approximate computing may be beneficial here, allowing computation to
run speculatively and results be analyzed after the computation to determine how
results fit, with the understanding that these results may not be accurate.



%%%%%%%%%%%%%%
