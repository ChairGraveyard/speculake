
\begin{abstract}
Recently, the Spectre and Meltdown attacks have revealed serious vulnerabilities in modern CPU
designs, allowing an attacker to exfiltrate data from sensitive programs. These
vulnerabilities take advantage of speculative execution to coerce a processor to
perform computation that would otherwise not occur, leaking the resulting
information via side channels to an attacker.

In this paper, we extend these ideas in a different direction, and leverage speculative
execution in order to \emph{hide malware} from both static and dynamic analysis. Using this
technique, critical portions of a malicious program's computation can be shielded from view,
such that even a debugger following an instruction-level trace of the
program cannot tell how its results were computed.

We introduce \emph{\speculake}\footnote{Executable Spectre}, which compiles
arbitrary malicious code into a seemingly-benign payload binary. When a separate
trigger program runs on the same machine, it mistrains the CPU's branch
predictor, causing the payload program to \emph{speculatively} execute code, and
communicating its results back to the rest of the payload program, changing its
behavior.

We study the extent and types of execution that can be performed
speculatively, and demonstrate several computations that can be
performed covertly. In particular, within speculative execution we are able to
decrypt memory using AES-NI instructions at over 5~kbps. Building on this, we
are additionally able to decrypt and interpret
a custom virtual machine language to perform arbitrary computation,
allowing us to create a covert dial-back shell that executes in a few
milliseconds. We also show how our corresponding trigger program
can be a pre-existing benign application already running on the system, and
demonstrate this concept with OpenSSL driven remotely by the attacker as a
trigger program.

%Finally, we describe defenses, but in all honesty, you're probably not going to like
%them.

\speculake demonstrates a new kind of malware that evades existing reverse
engineering and binary analysis techniques. Because its true functionality is
contained in seemingly unreachable dead code, and its control flow driven
externally by potentially any other program running at the same time, \speculake poses a
novel threat to state-of-the-art malware analysis techniques.




%We consider this to be a new thrust in attack vector research that harkens to work 
%done on hardware red-pills and weird machines. We demonstrate that unintended 
%functionality of architechture can be used to compose malicious programs with 
%new and different properties. This technique poses novel and unique challenges for 
%malware modeling efforts, as it forces an environment to either
%faithfully reproduce all hardware behaviors, or overcome a much larger burden of 
%reverse engineering. 


\end{abstract}

