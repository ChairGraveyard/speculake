
\begin{abstract}
Recently, the Spectre and Meltdown attacks have revealed serious vulnerabilities in modern CPU
designs, allowing an attacker to exfiltrate data from sensitive programs. These
vulnerabilities take advantage of speculative execution to coerce a processor to
perform computation that would otherwise not occur, leaking the resulting
information via side channels to an attacker.

In this paper, we extend these ideas in a different direction, and leverage speculative
execution in order to \emph{hide malware} from both static and dynamic analysis. Using this
technique, critical portions of a malicious program's computation can be shielded from view,
such that even a debugger following an instruction-level trace of the
program cannot tell how its results were computed.

We introduce \emph{\speculake}, which compiles arbitrary malicious code into a
seemingly-benign payload binary. When a separate trigger program performs a specific
pattern of indirect jumps, it (mis)trains the CPU's branch predictor. Subsequent
executions of the payload binary with similar jumps causes the CPU to mispredict its
branches and speculatively execute a malicious payload, which communicates
results back to the real world via side channels.

We study the extent and types of execution that can be performed in the
``speculative world'', and build tools that enable several computations to be
performed covertly. In particular, within speculative execution we are able to
decrypt memory using AES-NI instructions, and are able to interpret a custom
virtual machine language to perform arbitrary computation.
We also show how the trigger program
can be a pre-existing benign application already running on the system, and
demonstrate this concept with OpenSSL driven remotely by the attacker as our
trigger program.

%Finally, we describe defenses, but in all honesty, you're probably not going to like
%them.

We consider this to be a new thrust in attack vector research that harkens to work 
done on hardware red-pills and weird machines. We demonstrate that unintended 
functionality of architechture can be used to compose malicious programs with 
new and different properties. This technique poses novel and unique challenges for 
malware modeling efforts, as it forces an environment to either
faithfully reproduce all hardware behaviors, or overcome a much larger burden of 
reverse engineering. 


\end{abstract}

